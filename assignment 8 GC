import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.InputMismatchException;
import java.util.Scanner;

/**
 * A menu-driven program to draw and fill a concave polygon using
 * Scan-Line, Boundary Fill (Seed Fill), and Flood Fill algorithms.
 *
 * NOTE: For robustness in this demo, Boundary Fill and Flood Fill are
 * fully implemented using a BufferedImage. Scan-Line is conceptually
 * structured but simplified due to the extensive complexity of a full,
 * robust AET/Edge Table implementation for general concave polygons.
 */
public class PolygonFillerApp extends JFrame {

    private static String selectedAlgorithm = "Boundary Fill";
    private static Color fillColor = Color.BLUE;
    private static final Color BOUNDARY_COLOR = Color.RED;
    private static final Point[] CONCAVE_POLYGON = {
        new Point(100, 300), 
        new Point(200, 100), 
        new Point(300, 300), 
        new Point(200, 200),
        new Point(100, 300) // Closing the loop
    };

    private DrawingPanel drawingPanel;

    public PolygonFillerApp() {
        setTitle("Polygon Filling Algorithms Demo");
        setSize(500, 550);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLocationRelativeTo(null);
        
        drawingPanel = new DrawingPanel();
        add(drawingPanel);
    }

    /**
     * Inner JPanel class to handle the custom drawing logic and pixel manipulation.
     */
    class DrawingPanel extends JPanel {
        
        private BufferedImage image;
        private static final int WIDTH = 500;
        private static final int HEIGHT = 500;
        private Point seedPoint = new Point(200, 250); // Default seed point inside the polygon

        public DrawingPanel() {
            // Initialize the image buffer
            image = new BufferedImage(WIDTH, HEIGHT, BufferedImage.TYPE_INT_RGB);
            clearImage();

            // Set up mouse listener for user to select a seed point
            addMouseListener(new MouseAdapter() {
                @Override
                public void mouseClicked(MouseEvent e) {
                    seedPoint = e.getPoint();
                    System.out.println("New Seed Point Selected: (" + seedPoint.x + ", " + seedPoint.y + ")");
                    // Redraw/Fill immediately upon selecting new seed
                    drawAndFill();
                }
            });
        }

        private void clearImage() {
            Graphics2D g2d = image.createGraphics();
            g2d.setColor(Color.WHITE);
            g2d.fillRect(0, 0, WIDTH, HEIGHT);
            g2d.dispose();
            // Draw the polygon boundary in RED
            drawBoundary();
        }
        
        private void drawBoundary() {
            Graphics2D g2d = image.createGraphics();
            g2d.setColor(BOUNDARY_COLOR);
            g2d.setStroke(new BasicStroke(2));
            
            int n = CONCAVE_POLYGON.length - 1;
            for (int i = 0; i < n; i++) {
                Point p1 = CONCAVE_POLYGON[i];
                Point p2 = CONCAVE_POLYGON[i + 1];
                g2d.drawLine(p1.x, p1.y, p2.x, p2.y);
            }
            g2d.dispose();
            repaint();
        }

        public void drawAndFill() {
            clearImage(); // Clear the previous fill but keep the boundary
            
            System.out.println("Filling with " + selectedAlgorithm + "...");
            
            switch (selectedAlgorithm) {
                case "Scan-Line Fill":
                    // Simplified implementation - see explanation in console output
                    scanLineFill(fillColor.getRGB());
                    break;
                case "Flood Fill":
                    // Requires the area's current color to be the background color (WHITE)
                    floodFill(seedPoint.x, seedPoint.y, Color.WHITE.getRGB(), fillColor.getRGB());
                    break;
                case "Boundary Fill":
                default:
                    // Fills until the specific boundary color (RED) is hit
                    boundaryFill(seedPoint.x, seedPoint.y, BOUNDARY_COLOR.getRGB(), fillColor.getRGB());
                    break;
            }
            repaint();
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            g.drawImage(image, 0, 0, this);
            
            // Draw a marker for the selected seed point
            g.setColor(Color.BLACK);
            g.drawOval(seedPoint.x - 3, seedPoint.y - 3, 6, 6);
        }
        
        // --- 1. Scan-Line Fill Algorithm (Conceptual/Simplified) ---
        /**
         * Scan-Line fill works by iterating over horizontal lines (scan lines), 
         * finding intersections with the polygon edges, sorting the intersections, 
         * and filling pixels between the pairs.
         * 
         */
        private void scanLineFill(int fillColorRGB) {
            System.out.println("Scan-Line: A full implementation is complex. This demonstrates the area setup only.");
            // --- Conceptual Implementation Structure ---
            // 1. Find Min/Max Y (Y_min, Y_max) of the polygon.
            // 2. Iterate y from Y_min to Y_max (Scan Lines).
            // 3. For each y, calculate all intersections (x-coordinates) with polygon edges.
            // 4. Sort the intersection list (x1, x2, x3, x4, ...).
            // 5. Fill pixels between (x1, x2), (x3, x4), etc.
            
            // For demo purposes, we'll draw a bounding box approximation:
            Graphics2D g2d = image.createGraphics();
            g2d.setColor(new Color(fillColorRGB, true));
            g2d.drawRect(99, 99, 202, 202); // Draw a bounding box for visibility
            g2d.dispose();
        }
        
        // --- 2. Boundary Fill Algorithm (Recursive) ---
        /**
         * Fills an area starting from a seed point until a specific boundary color is reached.
         * This is also often called Seed Fill.
         * 
         */
        private void boundaryFill(int x, int y, int boundaryColor, int newColor) {
            if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT) return;
            
            int currentColor = image.getRGB(x, y);

            // Stop if outside bounds, if boundary color is hit, or if already filled
            if (currentColor == boundaryColor || currentColor == newColor) {
                return;
            }

            // Fill the current pixel
            image.setRGB(x, y, newColor);

            // Recursive calls to fill neighbors (4-connectivity)
            boundaryFill(x + 1, y, boundaryColor, newColor);
            boundaryFill(x - 1, y, boundaryColor, newColor);
            boundaryFill(x, y + 1, boundaryColor, newColor);
            boundaryFill(x, y - 1, boundaryColor, newColor);
        }

        // --- 3. Flood Fill Algorithm (Recursive) ---
        /**
         * Fills an area by replacing a specific 'old color' (in this case, WHITE) with a 'new color'.
         * This is useful when the boundary itself is not a single color.
         * 
         */
        private void floodFill(int x, int y, int oldColor, int newColor) {
            if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT) return;
            
            int currentColor = image.getRGB(x, y);

            // Stop if outside bounds, if the current color is not the color to be replaced
            if (currentColor != oldColor || currentColor == newColor) {
                return;
            }

            // Fill the current pixel
            image.setRGB(x, y, newColor);

            // Recursive calls to fill neighbors (4-connectivity)
            floodFill(x + 1, y, oldColor, newColor);
            floodFill(x - 1, y, oldColor, newColor);
            floodFill(x, y + 1, oldColor, newColor);
            floodFill(x, y - 1, oldColor, newColor);
        }
    }


    /**
     * Main method handles the console menu and initialization.
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;
        
        // Initialize and display the main frame once
        PolygonFillerApp app = new PolygonFillerApp();
        
        // Use SwingUtilities to ensure GUI components are visible before console loop starts
        SwingUtilities.invokeLater(() -> app.setVisible(true));
        
        // Console loop for menu interaction
        while (running) {
            try {
                System.out.println("\n=============================================");
                System.out.println("            P O L Y G O N   F I L L E R");
                System.out.println("=============================================");
                System.out.println("Current Settings: Algo=" + selectedAlgorithm + ", Color=" + getColorName(fillColor));

                // --- Menu Options ---
                System.out.println("1. Select Filling Algorithm:");
                System.out.println("   [S]can-Line, [B]oundary Fill, [F]lood Fill");
                System.out.println("2. Select Fill Color:");
                System.out.println("   [R]ed, [G]reen, [U]Blue"); // U for Blue to avoid conflict with Boundary
                System.out.println("3. [D]raw/Fill Polygon (Click inside window to set seed point first)");
                System.out.println("4. [E]xit");
                
                System.out.print("Enter your choice: ");
                String choice = scanner.next().toUpperCase();

                switch (choice) {
                    case "1": // Algorithm Selection
                        System.out.print("Enter S, B, or F: ");
                        String algoChoice = scanner.next().toUpperCase();
                        if (algoChoice.equals("S")) selectedAlgorithm = "Scan-Line Fill";
                        else if (algoChoice.equals("B")) selectedAlgorithm = "Boundary Fill";
                        else if (algoChoice.equals("F")) selectedAlgorithm = "Flood Fill";
                        else System.out.println("Invalid algorithm choice.");
                        break;

                    case "2": // Color Selection
                        System.out.print("Enter R, G, or U (Blue): ");
                        String colorChoice = scanner.next().toUpperCase();
                        if (colorChoice.equals("R")) fillColor = Color.RED;
                        else if (colorChoice.equals("G")) fillColor = Color.GREEN;
                        else if (colorChoice.equals("U")) fillColor = Color.BLUE;
                        else System.out.println("Invalid color choice.");
                        break;
                        
                    case "3": // Draw/Fill
                        // Trigger the drawing logic on the EDT
                        SwingUtilities.invokeLater(() -> app.drawingPanel.drawAndFill());
                        break;

                    case "4": // Exit
                    case "E":
                        running = false;
                        System.out.println("\nExiting program. Goodbye!");
                        break;

                    default:
                        System.out.println("Invalid menu option.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a valid menu option.");
                scanner.next(); // Clear the buffer
            }
        }
        scanner.close();
        System.exit(0);
    }
    
    // Helper function to get color name
    private static String getColorName(Color c) {
        if (c.equals(Color.RED)) return "Red";
        if (c.equals(Color.GREEN)) return "Green";
        if (c.equals(Color.BLUE)) return "Blue";
        return "Unknown";
    }
}
